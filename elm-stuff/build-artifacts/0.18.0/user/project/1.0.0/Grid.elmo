var _user$project$Grid$toggle = F3(
	function (row, col, grid) {
		return A4(_user$project$Matrix$update, grid, row, col, _user$project$Tile$toggle);
	});
var _user$project$Grid$revealSingle = F3(
	function (grid, row, col) {
		var _p0 = A3(_user$project$Matrix$get, grid, row, col);
		if (_p0.ctor === 'Just') {
			return A4(_user$project$Matrix$update, grid, row, col, _user$project$Tile$reveal);
		} else {
			return grid;
		}
	});
var _user$project$Grid$isTileMine = function (tile) {
	return tile.isMine;
};
var _user$project$Grid$placeRandomMine = F2(
	function (excludedCoords, _p1) {
		var _p2 = _p1;
		var _p9 = _p2._1;
		var colGenerator = A2(
			_mgold$elm_random_pcg$Random_Pcg$int,
			0,
			_user$project$Matrix$height(_p9));
		var rowGenerator = A2(
			_mgold$elm_random_pcg$Random_Pcg$int,
			0,
			_user$project$Matrix$width(_p9));
		var isAvailable = function (_p3) {
			var _p4 = _p3;
			var _p7 = _p4._0;
			var _p6 = _p4._1;
			var _p5 = A3(_user$project$Matrix$get, _p9, _p7, _p6);
			if (_p5.ctor === 'Just') {
				return !A2(
					_elm_lang$core$Set$member,
					{ctor: '_Tuple2', _0: _p7, _1: _p6},
					excludedCoords);
			} else {
				return false;
			}
		};
		var coordsGenerator = A2(
			_mgold$elm_random_pcg$Random_Pcg$filter,
			isAvailable,
			A2(_mgold$elm_random_pcg$Random_Pcg$pair, rowGenerator, colGenerator));
		var _p8 = A2(_mgold$elm_random_pcg$Random_Pcg$step, coordsGenerator, _p2._0);
		var row = _p8._0._0;
		var col = _p8._0._1;
		var newSeed = _p8._1;
		var newGrid = A4(
			_user$project$Matrix$update,
			_p9,
			row,
			col,
			function (tile) {
				return _elm_lang$core$Native_Utils.update(
					tile,
					{isMine: true});
			});
		return {ctor: '_Tuple2', _0: newSeed, _1: newGrid};
	});
var _user$project$Grid$placeMines = F3(
	function (numMines, excludedCoords, _p10) {
		var _p11 = _p10;
		return A3(
			_elm_lang$core$List$foldl,
			_elm_lang$core$Basics$always(
				_user$project$Grid$placeRandomMine(excludedCoords)),
			{ctor: '_Tuple2', _0: _p11._0, _1: _p11._1},
			A2(
				_elm_lang$core$List$repeat,
				numMines,
				{ctor: '_Tuple0'}));
	});
var _user$project$Grid$tileNumber = F3(
	function (grid, row, col) {
		return _elm_lang$core$List$length(
			A2(
				_elm_lang$core$List$filter,
				_user$project$Grid$isTileMine,
				A3(_user$project$Matrix$neighbors, grid, row, col)));
	});
var _user$project$Grid$recursiveReveal = F3(
	function (row, col, _p12) {
		var _p13 = _p12;
		var _p16 = _p13._0;
		var _p15 = _p13._1;
		if (A2(
			_elm_lang$core$Set$member,
			{ctor: '_Tuple2', _0: row, _1: col},
			_p16)) {
			return {ctor: '_Tuple2', _0: _p16, _1: _p15};
		} else {
			var _p14 = A3(_user$project$Matrix$get, _p15, row, col);
			if (_p14.ctor === 'Just') {
				var neighbors = A3(_user$project$Matrix$neighborCoords, _p15, row, col);
				var newSeenCoords = A2(
					_elm_lang$core$Set$insert,
					{ctor: '_Tuple2', _0: row, _1: col},
					_p16);
				var newGrid = A3(_user$project$Grid$revealSingle, _p15, row, col);
				var number = A3(_user$project$Grid$tileNumber, _p15, row, col);
				return _elm_lang$core$Native_Utils.eq(number, 0) ? A3(
					_elm_lang$core$List$foldl,
					_elm_lang$core$Basics$uncurry(_user$project$Grid$recursiveReveal),
					{ctor: '_Tuple2', _0: newSeenCoords, _1: newGrid},
					neighbors) : {ctor: '_Tuple2', _0: newSeenCoords, _1: newGrid};
			} else {
				return {ctor: '_Tuple2', _0: _p16, _1: _p15};
			}
		}
	});
var _user$project$Grid$revealNeighbors = F3(
	function (grid, row, col) {
		var _p17 = A3(
			_user$project$Grid$recursiveReveal,
			row,
			col,
			{ctor: '_Tuple2', _0: _elm_lang$core$Set$empty, _1: grid});
		var newGrid = _p17._1;
		return newGrid;
	});
var _user$project$Grid$reveal = F3(
	function (row, col, grid) {
		var _p18 = A3(_user$project$Matrix$get, grid, row, col);
		if (_p18.ctor === 'Just') {
			return (!_p18._0.isMarked) ? (_elm_lang$core$Native_Utils.eq(
				A3(_user$project$Grid$tileNumber, grid, row, col),
				0) ? A3(_user$project$Grid$revealNeighbors, grid, row, col) : A3(_user$project$Grid$revealSingle, grid, row, col)) : grid;
		} else {
			return grid;
		}
	});
var _user$project$Grid$revealJustNeighbors = F3(
	function (row, col, grid) {
		var _p19 = A3(_user$project$Matrix$get, grid, row, col);
		if (_p19.ctor === 'Just') {
			var flags = A2(
				_elm_lang$core$List$filter,
				function (tile) {
					return tile.isMarked;
				},
				A3(_user$project$Matrix$neighbors, grid, row, col));
			var neighbors = A3(_user$project$Matrix$neighborCoords, grid, row, col);
			var number = A3(_user$project$Grid$tileNumber, grid, row, col);
			return (_elm_lang$core$Native_Utils.eq(number, 0) || (!_elm_lang$core$Native_Utils.eq(
				_elm_lang$core$List$length(flags),
				number))) ? grid : A3(
				_elm_lang$core$List$foldl,
				_elm_lang$core$Basics$uncurry(_user$project$Grid$reveal),
				grid,
				neighbors);
		} else {
			return grid;
		}
	});
var _user$project$Grid$init = F4(
	function (height, width, numMines, seed) {
		var grid = A3(
			_user$project$Matrix$init,
			height,
			width,
			F2(
				function (row, col) {
					return _user$project$Tile$init(false);
				}));
		return A3(
			_user$project$Grid$placeMines,
			numMines,
			_elm_lang$core$Set$empty,
			{ctor: '_Tuple2', _0: seed, _1: grid});
	});
